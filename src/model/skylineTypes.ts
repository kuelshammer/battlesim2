/**
 * Skyline Spectrogram - 100-bucket percentile aggregation types
 *
 * Generated by Rust/WASM backend via run_skyline_analysis_wasm()
 */

export interface SpellSlotLevel {
    level: number;
    remaining: number;
    max: number;
}

export interface ResourceBreakdown {
    spellSlots: SpellSlotLevel[];
    shortRestFeatures: string[];
    longRestFeatures: string[];
    hitDice: number;
    hitDiceMax: number;
    totalEhp: number;
    maxEhp: number;
}

export interface CharacterBucketData {
    name: string;
    id: string;
    maxHp: number;
    hpPercent: number;
    resourcePercent: number;
    resourceBreakdown: ResourceBreakdown;
    deathRound: number | null;
    isDead: boolean;
}

export interface PercentileBucket {
    percentile: number; // 1-100
    runCount: number;
    characters: CharacterBucketData[];
    partyHpPercent: number;
    partyResourcePercent: number;
    deathCount: number;
}

export interface SkylineAnalysis {
    buckets: PercentileBucket[];
    totalRuns: number;
    partySize: number;
    encounterIndex: number | null;
}

/**
 * Canvas rendering configuration
 */
export interface SkylineCanvasConfig {
    width: number;
    height: number;
    padding: { top: number; right: number; bottom: number; left: number };
    colors: {
        hp: ColorScale;
        resources: ColorScale;
        death: string;
        grid: string;
        crosshair: string;
    };
}

export type ColorScale = {
    low: string;   // 0% (red/bad)
    midLow: string; // 25%
    mid: string;    // 50% (white/neutral)
    midHigh: string; // 75%
    high: string;   // 100% (blue/good)
};

/**
 * Interaction state for hover/crosshair
 */
export interface SkylineInteractionState {
    hoveredBucket: number | null; // 1-100, or null
    hoveredCharacter: string | null; // character ID, or null
}

/**
 * Props for SkylineCanvas component
 */
export interface SkylineCanvasProps {
    data: SkylineAnalysis;
    config?: Partial<SkylineCanvasConfig>;
    onHover?: (state: SkylineInteractionState) => void;
    onBucketClick?: (bucket: PercentileBucket) => void;
    className?: string;
}

/**
 * Color palette for diverging red-blue scale (colorblind-safe)
 * Uses Okabe-Ito palette with modifications for D&D aesthetic
 */
export const DEFAULT_SKYLINE_COLORS: ColorScale = {
    low: '#d73027',     // Red (0% - depleted)
    midLow: '#fc8d59',  // Orange-Red (25%)
    mid: '#f0f0f0',     // Off-white (50% - neutral)
    midHigh: '#91bfdb', // Light Blue (75%)
    high: '#4575b4',    // Deep Blue (100% - full)
};

/**
 * Convert value (0-100) to color using diverging scale
 */
export function valueToColor(value: number, scale: ColorScale): string {
    const clamped = Math.max(0, Math.min(100, value));

    if (clamped < 25) {
        // Interpolate between low and midLow
        const t = clamped / 25;
        return interpolateColor(scale.low, scale.midLow, t);
    } else if (clamped < 50) {
        // Interpolate between midLow and mid
        const t = (clamped - 25) / 25;
        return interpolateColor(scale.midLow, scale.mid, t);
    } else if (clamped < 75) {
        // Interpolate between mid and midHigh
        const t = (clamped - 50) / 25;
        return interpolateColor(scale.mid, scale.midHigh, t);
    } else {
        // Interpolate between midHigh and high
        const t = (clamped - 75) / 25;
        return interpolateColor(scale.midHigh, scale.high, t);
    }
}

/**
 * Linear interpolation between two hex colors
 */
function interpolateColor(color1: string, color2: string, t: number): string {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);

    if (!c1 || !c2) return color1;

    const r = Math.round(c1.r + (c2.r - c1.r) * t);
    const g = Math.round(c1.g + (c2.g - c1.g) * t);
    const b = Math.round(c1.b + (c2.b - c1.b) * t);

    return rgbToHex(r, g, b);
}

function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
        }
        : null;
}

function rgbToHex(r: number, g: number, b: number): string {
    return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}
